[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About",
    "section": "",
    "text": "This website contains my ongoing assignments for the course Introduction to Computational Modeling of Behavior (HS24, University of Zurich).\nAuthor: Laura Ferretti\n\n\n\n\n\n Back to top",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "hw2/index.html",
    "href": "hw2/index.html",
    "title": "Assignment 2: Replicate Simulation",
    "section": "",
    "text": "Make list with normal distribution data\n\n\nCode\nN  &lt;- 5000 # Default size of the population\nMU &lt;- 100 # Default mean of the population\n\npopulation &lt;- rnorm(N, mean = MU, sd = MU / 5)\nhist(population) #check whether it's normally distributed\n\n\n\n\n\n\n\n\n\nCompute Gini coefficient\n\n\nCode\ngini &lt;- function(y) {\n  #Compute the Gini coefficient (a measure of equality/inequality) in a population, y\n  y &lt;- sort(y)\n  n &lt;- length(y)\n  numer &lt;- 2 * sum((1:n) * y[1:n]) #for i in range starts with 0 in python, indexing also with 0\n  denom &lt;- n * sum(y)\n   return((numer / denom) - (n + 1) / n) #brackets are needed for return fun in R\n}\ngini(population)\n\n\n[1] 0.1128566\n\n\nDefine Transactions function\n\n\nCode\nrandom_split &lt;- function(A, B) {\n  #Take all the money in the pot and divide it randomly between the two actors\n  pot &lt;- A + B\n  share &lt;- runif(1,0,pot)\n  return(c(share, pot-share))\n}\nrandom_split(100,100)\n\n\n[1]  14.7597 185.2403\n\n\nDefine Interaction function\n\n\nCode\nanyone &lt;- function(N) {\n return(sample(N,2))\n}\n\nanyone(N)\n\n\n[1] 620 512\n\n\nSimulation\nFirst, I need to figure out, whether my code idea will work\nNow I can define the function that will split the money between two agents and save the new money that they have for each agent (one step of the simulation)\n\n\nCode\nstep &lt;- function(population, transaction_fun=random_split, interaction_fun=anyone) {\n  #Modify the population by doing one transaction.\n  j &lt;- interaction_fun(length(population))\n  newmoney &lt;- transaction_fun(population[j[1]], population[j[2]]) \n  population[j[1]] &lt;- newmoney[1]\n  population[j[2]] &lt;- newmoney[2]\n return(population)\n}\n\n\nNow I can define the function of the whole simulation\n\n\nCode\nsimulate &lt;- function(population, T, step_fun=step, transaction_fun=random_split, interaction_fun=anyone) {\n  # Run simulation on population for T transactions; save every step in a list\n  pop_copy &lt;- population # Make a copy of the original population list to avoid altering it\n\n  # Initialize an empty list to store steps\n  list_steps &lt;- list()\n  \n  # Save the initial population (at t = 0)\n  list_steps[[1]] &lt;- list(population = pop_copy, t = 0)\n  \n  # Simulate T steps\n  for (t in 1:T) {\n    # Update population using the step function\n    pop_copy &lt;- step_fun(pop_copy, transaction_fun, interaction_fun)\n    \n    # Save the current population and the step number\n    list_steps[[t + 1]] &lt;- list(population = pop_copy, t = t)\n  }\n  \n  return(list_steps)  # Return the list of steps\n}\n\ntest &lt;- simulate(population = c(100,100,100,100), T=10)\n\n\nSimulation Visualization\n\n\nCode\nshow &lt;- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {\n    #Run a simulation for k*N steps, printing statistics and displaying a plot and histogram\n  N &lt;- length(population)\n\n  # Run simulation\ny &lt;- simulate(population, T=N*k)#every person does k transactions\n  cat('   t    Gini stdev', sprintf(' %3d%%', percentiles), '\\n')\n   cat('------- ---- -----', paste(rep(' ---- ', length(percentiles)), collapse = ''), '\\n')\n   fmt &lt;- '%7d %.2f %5.1f'\n   \n   #make sure that the first row is added (in my simulation result, the first row has the 0 step)\n   pop &lt;- sort(y[[1]]$population)\n      data &lt;- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[1]]$t, gini(y[[1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n   \n\n  for (l in 1:N*k) {\n    if ((l %% (N*k %/% 10)) == 0) {#only save ten steps (which is divisable in ten steps)\n      \n      pop &lt;- sort(y[[l+1]]$population)\n      data &lt;- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[l+1]]$t, gini(y[[l+1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n    }\n  }\n       ### Making histogram ###\n    #    R &lt;- range(c(y[[1]]$population, y[[length(y)]]$population)) # Combines 'start' and 'pop' and computes the range\n    # \n    # # Create the histogram for the start population\n    # hist(start, main=\"Histograms: Start\", xlim=R, col=rgb(0.2, 0.4, 0.6, 0.7), \n    #      xlab=\"Wealth\", ylab=\"Frequency\")\n    # \n    # # Overlay the histogram for the end population\n    # hist(pop, main=\"Histograms: End\", xlim=R, col=rgb(0.8, 0.2, 0.2, 0.5), \n    #      add=TRUE, xlab=\"Wealth\", ylab=\"Frequency\")\n    # \n    # # Add a legend to differentiate the histograms\n    # legend(\"topright\", legend=c(\"Start\", \"End\"), fill=c(rgb(0.2, 0.4, 0.6, 0.7), \n    #        rgb(0.8, 0.2, 0.2, 0.5)))\n  \n} \n\nshow(population = c(100,100,100,100,100,100,100,100,100,100))\n\n\n   t    Gini stdev    1%   10%   50%   90%   99% \n------- ---- -----  ----  ----  ----  ----  ----  \n      0 0.00   0.0   100   100   100   100   100 \n     40 0.41  80.3    15    20    81   186   260 \n     80 0.47  90.9     9    16    76   214   281 \n    120 0.36  69.2    18    30    85   190   230 \n    160 0.35  66.1     4    25    89   186   188 \n    200 0.37  70.6    21    28    92   185   221 \n    240 0.43  81.9    12    15    94   197   214 \n    280 0.43  80.0     2     7   114   192   206 \n    320 0.50  97.6     7     8    68   202   292 \n    360 0.64 171.0     6    14    36   194   534 \n    400 0.37  72.8    33    33    72   214   228 \n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This website contains my ongoing assignments for the course Introduction to Computational Modeling of Behavior (HS24, University of Zurich).\nAuthor: Laura Ferretti\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "hw1/index.html",
    "href": "hw1/index.html",
    "title": "Assignment 1: Hello World",
    "section": "",
    "text": "In this introductory assignment, I just want you to make a simple plot. Here is an example:\n\n\nCode\nx &lt;- rnorm(10000, mean = 100, sd = 15)\nhist(x)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "About",
      "Assignment 1: Hello World"
    ]
  },
  {
    "objectID": "hw2_fin/index.html",
    "href": "hw2_fin/index.html",
    "title": "Assignment 2: Simulation",
    "section": "",
    "text": "Simulation\nMake list with normal distribution data\n\n\nCode\nN  &lt;- 5000 # Default size of the population\nMU &lt;- 100 # Default mean of the population\n\npopulation &lt;- rnorm(N, mean = MU, sd = MU / 5)\nhist(population) #check whether it's normally distributed\n\n\n\n\n\n\n\n\n\nCompute Gini coefficient\n\n\nCode\ngini &lt;- function(y) {\n  #Compute the Gini coefficient (a measure of equality/inequality) in a population, y\n  y &lt;- sort(y)\n  n &lt;- length(y)\n  numer &lt;- 2 * sum((1:n) * y[1:n]) #for i in range starts with 0 in python, indexing also with 0\n  denom &lt;- n * sum(y)\n   return((numer / denom) - (n + 1) / n) #brackets are needed for return fun in R\n}\ngini(population)\n\n\n[1] 0.1135069\n\n\nDefine Transactions function\n\n\nCode\nrandom_split &lt;- function(A, B) {\n  #Take all the money in the pot and divide it randomly between the two actors\n  pot &lt;- A + B\n  share &lt;- runif(1,0,pot)\n  return(c(share, pot-share))\n}\nrandom_split(100,100)\n\n\n[1]  31.6513 168.3487\n\n\nDefine Interaction function\n\n\nCode\nanyone &lt;- function(N) {\n return(sample(N,2))\n}\n\nanyone(N)\n\n\n[1] 3281 1468\n\n\nSimulation\nFirst, I need to figure out, whether my code idea will work.\n\n\nCode\nj &lt;- anyone(length(population))\nj\npopulation[941]\npopulation[j[1]]\npopulation[2724]\npopulation[j[2]]\nnewmoney &lt;- random_split(population[j[1]], population[j[2]]) \nnewmoney\npopulation[j[1]] &lt;- newmoney[1]\npopulation[j[2]] &lt;- newmoney[2]\n\npopulation[j[1]]\npopulation[j[2]]\n\n\nNow I can define the function that will split the money between two agents and save the new money that they have for each agent (one step of the simulation)\n\n\nCode\nstep &lt;- function(population, transaction_fun=random_split, interaction_fun=anyone) {\n  #Modify the population by doing one transaction.\n  j &lt;- interaction_fun(length(population))\n  newmoney &lt;- transaction_fun(population[j[1]], population[j[2]]) \n  population[j[1]] &lt;- newmoney[1]\n  population[j[2]] &lt;- newmoney[2]\n return(population)\n}\n\n\nNow I can define the function of the whole simulation\n\n\nCode\nsimulate &lt;- function(population, T, step_fun=step, transaction_fun=random_split, interaction_fun=anyone) {\n  # Run simulation on population for T transactions; save every step in a list\n  pop_copy &lt;- population # Make a copy of the original population list to avoid altering it\n\n  # Initialize an empty list to store steps\n  list_steps &lt;- list()\n  \n  # Save the initial population (at t = 0)\n  list_steps[[1]] &lt;- list(population = pop_copy, t = 0)\n  \n  # Simulate T steps\n  for (t in 1:T) {\n    # Update population using the step function\n    pop_copy &lt;- step_fun(pop_copy, transaction_fun, interaction_fun)\n    \n    # Save the current population and the step number\n    list_steps[[t + 1]] &lt;- list(population = pop_copy, t = t)\n  }\n  \n  return(list_steps)  # Return the list of steps\n}\n\ntest &lt;- simulate(population = c(100,100,100,100), T=10)\n\n\nSimulation Visualization\n\n\nCode\nshow &lt;- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {\n    #Run a simulation for k*N steps, printing statistics and displaying a plot and histogram\n  N &lt;- length(population)\n\n  # Run simulation\ny &lt;- simulate(population, T=N*k)#every person does k transactions\n  cat('   t    Gini stdev', sprintf(' %3d%%', percentiles), '\\n')\n   cat('------- ---- -----', paste(rep(' ---- ', length(percentiles)), collapse = ''), '\\n')\n   fmt &lt;- '%7d %.2f %5.1f'\n   \n   #make sure that the first row is added (in my simulation result, the first row has the 0 step)\n   pop &lt;- sort(y[[1]]$population)\n      data &lt;- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[1]]$t, gini(y[[1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n   \n\n  for (l in 1:N*k) {\n    if ((l %% (N*k %/% 10)) == 0) {#only save ten steps (which is divisable in ten steps)\n      \n      pop &lt;- sort(y[[l+1]]$population)\n      data &lt;- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[l+1]]$t, gini(y[[l+1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n    }\n  }\n    \n       \n# Making histogram \nbreaks &lt;- seq(min(c(y[[N*k]][[\"population\"]], y[[1]][[\"population\"]])), \n               max(c(y[[N*k]][[\"population\"]], y[[1]][[\"population\"]])), \n               length.out = 30)\n       \n hist(y[[N*k]][[\"population\"]],col = rgb(1, 0, 0, 0.3), main = \"Overlapping Histograms\", xlab = \"Wealth\", ylab = \"Count\", breaks=breaks) \n \n # Overlay the second histogram\nhist(y[[1]][[\"population\"]], col = rgb(0, 0, 1, 0.3), add = TRUE, breaks=breaks)\n \nlegend(\"topright\", legend = c(\"End\", \"Start\"), \n       fill = c(rgb(1, 0, 0, 0.3), rgb(0, 0, 1, 0.3))) \n  \n} \n\n\n\n\nPart 2 of the Assignment\nStarting with normal distribution:\n\n\nCode\nshow(population)\n\n\n   t    Gini stdev    1%   10%   50%   90%   99% \n------- ---- -----  ----  ----  ----  ----  ----  \n      0 0.11  20.1    53    74   100   126   145 \n  20000 0.49  96.2     1    11    71   228   440 \n  40000 0.50 101.1     1    11    68   228   463 \n  60000 0.51 102.2     1    10    67   231   484 \n  80000 0.50  99.1     1    11    68   229   452 \n 100000 0.50  98.8     1    11    70   231   448 \n 120000 0.50 101.0     1    11    68   230   475 \n 140000 0.50  99.4     1    11    68   224   460 \n 160000 0.50 101.4     1    10    68   232   462 \n 180000 0.50 100.2     1    10    67   231   450 \n 200000 0.50 100.6     1    11    68   229   453 \n\n\n\n\n\n\n\n\n\nWhat if everybody starts with the same amount of money:\n\n\nCode\nN  &lt;- 5000 # Default size of the population\ninitial_money &lt;- 100 # Beggining wealth\n\npopulation2 &lt;- rep(initial_money, N)\nhist(population2) #check whether it's equally distributed\n\n\n\n\n\n\n\n\n\nCode\nshow(population2)\n\n\n   t    Gini stdev    1%   10%   50%   90%   99% \n------- ---- -----  ----  ----  ----  ----  ----  \n      0 0.00   0.0   100   100   100   100   100 \n  20000 0.48  94.2     1    12    72   229   416 \n  40000 0.50  99.0     1    10    71   227   449 \n  60000 0.51 101.8     1    10    68   230   470 \n  80000 0.50 102.5     1    11    67   232   456 \n 100000 0.51 101.3     1    10    67   233   463 \n 120000 0.50  99.4     1    11    68   232   455 \n 140000 0.51 102.4     1    10    68   230   472 \n 160000 0.50 100.8     1    10    68   233   452 \n 180000 0.50 100.0     1    11    71   230   466 \n 200000 0.50 100.1     1    11    68   229   459 \n\n\n\n\n\n\n\n\n\nThere is still the same final pattern and the same final Gini coeffcient. The starting distribution seems to be irrelevant. From looking at the table, it seems like the switch to the final distribution happens quite quickly (already after 2000 transactions). Let me look at it more closely.\n\n\nCode\nshow2 &lt;- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {\n    #Run a simulation for k*N steps, printing statistics and displaying a plot and histogram\n  N &lt;- length(population)\n\n  # Run simulation\ny &lt;- simulate(population, T=N*k)#every person does k transactions\n  cat('   t    Gini stdev', sprintf(' %3d%%', percentiles), '\\n')\n   cat('------- ---- -----', paste(rep(' ---- ', length(percentiles)), collapse = ''), '\\n')\n   fmt &lt;- '%7d %.2f %5.1f'\n   \n   #make sure that the first row is added (in my simulation result, the first row has the 0 step)\n   pop &lt;- sort(y[[1]]$population)\n      data &lt;- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[1]]$t, gini(y[[1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n   \n\n  for (l in 1:N*k) {\n    if ((l %% (N*k %/% 20)) == 0) {#only save 20 steps (which is divisable in ten steps)\n      \n      pop &lt;- sort(y[[l+1]]$population)\n      data &lt;- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[l+1]]$t, gini(y[[l+1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n    }\n  }\n    \n       \n       ## Making histogram ###\nbreaks &lt;- seq(min(c(y[[N*k]][[\"population\"]], y[[1]][[\"population\"]])), \n               max(c(y[[N*k]][[\"population\"]], y[[1]][[\"population\"]])), \n               length.out = 30)\n       \n hist(y[[N*k]][[\"population\"]],col = rgb(1, 0, 0, 0.3), main = \"Normal distribution, with middle distribution of wealth\", xlab = \"Wealth\", ylab = \"Count\") \n \n # Overlay the second histogram\nhist(y[[1]][[\"population\"]], col = rgb(0, 0, 1, 0.3), add = TRUE)\n\nhist(y[[(N*k)/2]][[\"population\"]], col = rgb(0, 1, 0, 0.3), add = TRUE)\n \nlegend(\"topright\", legend = c(\"End\", \"Start\", \"Middle\"), \n       fill = c(rgb(1, 0, 0, 0.3), rgb(0, 0, 1, 0.3),rgb(0, 1, 0, 0.3))) \n  \n} \n\nshow2(population)\n\n\n   t    Gini stdev    1%   10%   50%   90%   99% \n------- ---- -----  ----  ----  ----  ----  ----  \n      0 0.11  20.1    53    74   100   126   145 \n  10000 0.45  85.7     1    13    80   211   394 \n  20000 0.49  97.4     1    10    70   230   438 \n  30000 0.49  97.5     1    10    69   227   456 \n  40000 0.49  98.4     1    12    71   229   456 \n  50000 0.49  99.1     1    11    71   222   464 \n  60000 0.50  98.7     1    11    71   231   453 \n  70000 0.50 100.1     1    11    69   221   464 \n  80000 0.50  99.9     1    10    69   230   461 \n  90000 0.50  99.1     1    10    70   231   447 \n 100000 0.50 100.9     1    10    69   233   452 \n 110000 0.50  99.5     1    10    69   230   452 \n 120000 0.50  98.9     1    10    69   229   447 \n 130000 0.50  99.0     1    11    69   234   441 \n 140000 0.50 100.7     1    10    69   229   483 \n 150000 0.50  99.2     1    10    68   231   445 \n 160000 0.51 100.6     1    10    67   233   454 \n 170000 0.50  99.2     1    11    68   232   454 \n 180000 0.50 100.3     1    11    69   229   453 \n 190000 0.51 100.3     1    10    68   234   441 \n 200000 0.50  99.9     1    11    68   232   443 \n\n\n\n\n\n\n\n\n\nIt seems that it finds a state where it’s in a stable distribution and then more or less stays like this (Gini changes from 0.49-0.51). Looking at the table, it seems to happen rather quickly. If every meeting and distribution happens randomly, could it be that the distribution randomly lands on this “stable distribution” but then stays like that? Why does it stay like that? I’d like to use a smaller population to see what happens in this case.\n\n\nCode\nshow(population = c(100,100,100,100,100,100,100,100,100,100))\n\n\n   t    Gini stdev    1%   10%   50%   90%   99% \n------- ---- -----  ----  ----  ----  ----  ----  \n      0 0.00   0.0   100   100   100   100   100 \n     40 0.38  71.7     7    23    98   171   210 \n     80 0.53 105.4     2    19    63   247   309 \n    120 0.36  68.9    19    22    81   163   226 \n    160 0.48  94.1     6    16    78   195   297 \n    200 0.56 173.7    20    30    47   130   546 \n    240 0.49  94.3     4    13    55   203   269 \n    280 0.39  72.5     8    17   107   190   190 \n    320 0.42  93.3    27    34    77   150   322 \n    360 0.42  79.5     6    13    88   178   244 \n    400 0.34  63.4    11    15   101   177   191 \n\n\n\n\n\n\n\n\n\nLet me look at each step in this smaller simulation.\n\n\nCode\ntest &lt;- simulate(population = c(100,100,100,100,100,100,100,100,100,100), 40)\ntest\n\n\nI would describe two facts that can be observed:\n1) Since the distribution is random, there’s a small probability that it will be split in half. There are more situations were one person gets more money and the other gets less. This gets repeatedly enough times, so that there is less equality. But why does the inequality stabilize were many people are poor?\nThe general amount of money is the same in the end and in the beginning. It only gets distributed. A distribution were many people are wealthy and not a lot of people are poor isn’t possible because of this.\n2) If many people don’t have a lot of wealth, there’s a higher probability that two people will meet who don’t have a lot of money. In this case it will randomly be divided, but the beginning pool will be rather small. There are not a lot of people who have a lot of money, the probably is high, that they will meet someone who doesn’t have a lot of money.\nIn the graph above with the title “Normal distribution, with middle distribution of wealth”, we can see that in the middle, there are some people who are richer than in the end distribution. That means and even the wealthy people get poorer.\n\n\n\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "About",
      "Assignment 2: Simulation"
    ]
  }
]