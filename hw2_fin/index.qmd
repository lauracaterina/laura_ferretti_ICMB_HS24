---
title: "Assignment 2: Simulation"
---

# **Simulation**

**Make list with normal distribution data**

```{r}
N  <- 5000 # Default size of the population
MU <- 100 # Default mean of the population

population <- rnorm(N, mean = MU, sd = MU / 5)
hist(population) #check whether it's normally distributed
```

**Compute Gini coefficient**

```{r}
gini <- function(y) {
  #Compute the Gini coefficient (a measure of equality/inequality) in a population, y
  y <- sort(y)
  n <- length(y)
  numer <- 2 * sum((1:n) * y[1:n]) #for i in range starts with 0 in python, indexing also with 0
  denom <- n * sum(y)
   return((numer / denom) - (n + 1) / n) #brackets are needed for return fun in R
}
gini(population)
```

**Define Transactions function**

```{r}
random_split <- function(A, B) {
  #Take all the money in the pot and divide it randomly between the two actors
  pot <- A + B
  share <- runif(1,0,pot)
  return(c(share, pot-share))
}
random_split(100,100)
```

**Define Interaction function**

```{r}
anyone <- function(N) {
 return(sample(N,2))
}

anyone(N)

```

**Simulation**

First, I need to figure out, whether my code idea will work.

```{r, results="hide"}

j <- anyone(length(population))
j
population[941]
population[j[1]]
population[2724]
population[j[2]]
newmoney <- random_split(population[j[1]], population[j[2]]) 
newmoney
population[j[1]] <- newmoney[1]
population[j[2]] <- newmoney[2]

population[j[1]]
population[j[2]]
```

Now I can define the function that will split the money between two agents and save the new money that they have for each agent (one step of the simulation)

```{r}
step <- function(population, transaction_fun=random_split, interaction_fun=anyone) {
  #Modify the population by doing one transaction.
  j <- interaction_fun(length(population))
  newmoney <- transaction_fun(population[j[1]], population[j[2]]) 
  population[j[1]] <- newmoney[1]
  population[j[2]] <- newmoney[2]
 return(population)
}
```

Now I can define the function of the whole simulation

```{r}
simulate <- function(population, T, step_fun=step, transaction_fun=random_split, interaction_fun=anyone) {
  # Run simulation on population for T transactions; save every step in a list
  pop_copy <- population # Make a copy of the original population list to avoid altering it

  # Initialize an empty list to store steps
  list_steps <- list()
  
  # Save the initial population (at t = 0)
  list_steps[[1]] <- list(population = pop_copy, t = 0)
  
  # Simulate T steps
  for (t in 1:T) {
    # Update population using the step function
    pop_copy <- step_fun(pop_copy, transaction_fun, interaction_fun)
    
    # Save the current population and the step number
    list_steps[[t + 1]] <- list(population = pop_copy, t = t)
  }
  
  return(list_steps)  # Return the list of steps
}

test <- simulate(population = c(100,100,100,100), T=10)

    
```

**Simulation Visualization**

```{r}

  
show <- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {
    #Run a simulation for k*N steps, printing statistics and displaying a plot and histogram
  N <- length(population)

  # Run simulation
y <- simulate(population, T=N*k)#every person does k transactions
  cat('   t    Gini stdev', sprintf(' %3d%%', percentiles), '\n')
   cat('------- ---- -----', paste(rep(' ---- ', length(percentiles)), collapse = ''), '\n')
   fmt <- '%7d %.2f %5.1f'
   
   #make sure that the first row is added (in my simulation result, the first row has the 0 step)
   pop <- sort(y[[1]]$population)
      data <- sapply(percentiles, function(pct) quantile(pop, pct/100))
       cat(sprintf(fmt, y[[1]]$t, gini(y[[1]]$population), sd(pop)), 
          sprintf(' %4.0f', data), '\n')
   

  for (l in 1:N*k) {
    if ((l %% (N*k %/% 10)) == 0) {#only save ten steps (which is divisable in ten steps)
      
      pop <- sort(y[[l+1]]$population)
      data <- sapply(percentiles, function(pct) quantile(pop, pct/100))
       cat(sprintf(fmt, y[[l+1]]$t, gini(y[[l+1]]$population), sd(pop)), 
          sprintf(' %4.0f', data), '\n')
    }
  }
    
       
# Making histogram 
breaks <- seq(min(c(y[[N*k]][["population"]], y[[1]][["population"]])), 
               max(c(y[[N*k]][["population"]], y[[1]][["population"]])), 
               length.out = 30)
       
 hist(y[[N*k]][["population"]],col = rgb(1, 0, 0, 0.3), main = "Overlapping Histograms", xlab = "Wealth", ylab = "Count", breaks=breaks) 
 
 # Overlay the second histogram
hist(y[[1]][["population"]], col = rgb(0, 0, 1, 0.3), add = TRUE, breaks=breaks)
 
legend("topright", legend = c("End", "Start"), 
       fill = c(rgb(1, 0, 0, 0.3), rgb(0, 0, 1, 0.3))) 
  
} 


```

# **Part 2 of the Assignment**

**Starting with normal distribution:**

```{r}
show(population)
```

What if everybody starts with the same amount of money:

```{r}
N  <- 5000 # Default size of the population
initial_money <- 100 # Beggining wealth

population2 <- rep(initial_money, N)
hist(population2) #check whether it's equally distributed

show(population2)
```

There is still the same final pattern and the same final Gini coeffcient. The starting distribution seems to be irrelevant. From looking at the table, it seems like the switch to the final distribution happens quite quickly (already after 2000 transactions). Let me look at it more closely.

```{r}
show2 <- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {
    #Run a simulation for k*N steps, printing statistics and displaying a plot and histogram
  N <- length(population)

  # Run simulation
y <- simulate(population, T=N*k)#every person does k transactions
  cat('   t    Gini stdev', sprintf(' %3d%%', percentiles), '\n')
   cat('------- ---- -----', paste(rep(' ---- ', length(percentiles)), collapse = ''), '\n')
   fmt <- '%7d %.2f %5.1f'
   
   #make sure that the first row is added (in my simulation result, the first row has the 0 step)
   pop <- sort(y[[1]]$population)
      data <- sapply(percentiles, function(pct) quantile(pop, pct/100))
       cat(sprintf(fmt, y[[1]]$t, gini(y[[1]]$population), sd(pop)), 
          sprintf(' %4.0f', data), '\n')
   

  for (l in 1:N*k) {
    if ((l %% (N*k %/% 20)) == 0) {#only save 20 steps (which is divisable in ten steps)
      
      pop <- sort(y[[l+1]]$population)
      data <- sapply(percentiles, function(pct) quantile(pop, pct/100))
       cat(sprintf(fmt, y[[l+1]]$t, gini(y[[l+1]]$population), sd(pop)), 
          sprintf(' %4.0f', data), '\n')
    }
  }
    
       
       ## Making histogram ###
breaks <- seq(min(c(y[[N*k]][["population"]], y[[1]][["population"]])), 
               max(c(y[[N*k]][["population"]], y[[1]][["population"]])), 
               length.out = 30)
       
 hist(y[[N*k]][["population"]],col = rgb(1, 0, 0, 0.3), main = "Normal distribution, with middle distribution of wealth", xlab = "Wealth", ylab = "Count") 
 
 # Overlay the second histogram
hist(y[[1]][["population"]], col = rgb(0, 0, 1, 0.3), add = TRUE)

hist(y[[(N*k)/2]][["population"]], col = rgb(0, 1, 0, 0.3), add = TRUE)
 
legend("topright", legend = c("End", "Start", "Middle"), 
       fill = c(rgb(1, 0, 0, 0.3), rgb(0, 0, 1, 0.3),rgb(0, 1, 0, 0.3))) 
  
} 

show2(population)
```

It seems that it finds a state where it's in a stable distribution and then more or less stays like this (Gini changes from 0.49-0.51). Looking at the table, it seems to happen rather quickly. If every meeting and distribution happens randomly, could it be that the distribution randomly lands on this "stable distribution" but then stays like that? Why does it stay like that? I'd like to use a smaller population to see what happens in this case.

```{r}
show(population = c(100,100,100,100,100,100,100,100,100,100))
```

Let me look at each step in this smaller simulation.

```{r, results='hide'}
test <- simulate(population = c(100,100,100,100,100,100,100,100,100,100), 40)
test

```

I would describe two facts that can be observed:

1\) Since the distribution is random, there's a small probability that it will be split in half. There are more situations were one person gets more money and the other gets less. This gets repeatedly enough times, so that there is less equality. But why does the inequality stabilize were many people are poor?

The general amount of money is the same in the end and in the beginning. It only gets distributed. A distribution were many people are wealthy and not a lot of people are poor isn't possible because of this.

2\) If many people don't have a lot of wealth, there's a higher probability that two people will meet who don't have a lot of money. In this case it will randomly be divided, but the beginning pool will be rather small. There are not a lot of people who have a lot of money, the probably is high, that they will meet someone who doesn't have a lot of money.

In the histogram above with three steps (including the middle step), we can see that in the middle, there are some people who are richer than in the end distribution. That means and even the wealthy people get poorer.

\
\
