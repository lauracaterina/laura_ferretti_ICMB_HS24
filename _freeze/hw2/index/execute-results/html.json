{
  "hash": "65b5c0678fe357a39977bd94ad744c82",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Assignment 2: Replicate Simulation\"\n---\n\n\n\n\n**Make list with normal distribution data**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN  <- 5000 # Default size of the population\nMU <- 100 # Default mean of the population\n\npopulation <- rnorm(N, mean = MU, sd = MU / 5)\nhist(population) #check whether it's normally distributed\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n\n**Compute Gini coefficient**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngini <- function(y) {\n  #Compute the Gini coefficient (a measure of equality/inequality) in a population, y\n  y <- sort(y)\n  n <- length(y)\n  numer <- 2 * sum((1:n) * y[1:n]) #for i in range starts with 0 in python, indexing also with 0\n  denom <- n * sum(y)\n   return((numer / denom) - (n + 1) / n) #brackets are needed for return fun in R\n}\ngini(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1128566\n```\n\n\n:::\n:::\n\n\n\n\n**Define Transactions function**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_split <- function(A, B) {\n  #Take all the money in the pot and divide it randomly between the two actors\n  pot <- A + B\n  share <- runif(1,0,pot)\n  return(c(share, pot-share))\n}\nrandom_split(100,100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  14.7597 185.2403\n```\n\n\n:::\n:::\n\n\n\n\n**Define Interaction function**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanyone <- function(N) {\n return(sample(N,2))\n}\n\nanyone(N)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 620 512\n```\n\n\n:::\n:::\n\n\n\n\n**Simulation**\n\nFirst, I need to figure out, whether my code idea will work\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nNow I can define the function that will split the money between two agents and save the new money that they have for each agent (one step of the simulation)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep <- function(population, transaction_fun=random_split, interaction_fun=anyone) {\n  #Modify the population by doing one transaction.\n  j <- interaction_fun(length(population))\n  newmoney <- transaction_fun(population[j[1]], population[j[2]]) \n  population[j[1]] <- newmoney[1]\n  population[j[2]] <- newmoney[2]\n return(population)\n}\n```\n:::\n\n\n\n\nNow I can define the function of the whole simulation\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate <- function(population, T, step_fun=step, transaction_fun=random_split, interaction_fun=anyone) {\n    #Run simulation on population for T transactions; save every step in list\n  pop_copy <- population #I can directly copy, doesn't change og pop list\n  \n  #instead of yield, make a list\n  list_steps <- list()\n\n  list_steps[[1]] <- pop_copy\n  \n  for (t in 1:T) {\n    pop_copy <- step_fun(population, transaction_fun, interaction_fun)\n    list_steps[[t + 1]] <- pop_copy\n  }\n  return(list_steps)\n}\n\n\nsimulate(population = c(100,100,100,100), T=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 100 100 100 100\n\n[[2]]\n[1] 100.00000  47.51528 152.48472 100.00000\n\n[[3]]\n[1]  37.24665 100.00000 100.00000 162.75335\n\n[[4]]\n[1] 117.20641 100.00000 100.00000  82.79359\n\n[[5]]\n[1] 100.00000 100.00000  37.58592 162.41408\n\n[[6]]\n[1] 112.88071 100.00000  87.11929 100.00000\n\n[[7]]\n[1] 124.8944  75.1056 100.0000 100.0000\n\n[[8]]\n[1]  34.6397 165.3603 100.0000 100.0000\n\n[[9]]\n[1] 163.4966 100.0000 100.0000  36.5034\n\n[[10]]\n[1] 100.00000 100.00000 103.50885  96.49115\n\n[[11]]\n[1] 100.00000 100.00000  52.48393 147.51607\n```\n\n\n:::\n:::\n\n\n\n\n**Simulation Visualization**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow <- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {\n    #Run a simulation for k*N steps, printing statistics and displaying a plot and histogram\n  N <- length(population)\n\n  # Run simulation\ny <- simulate(population, T=N*k)#every person does k transactions\n  \n  results <- data.frame()\n  for (t in 1:N*k) {\n    if ((t %% (N*k %/% 10)) == 0) {#only save ten steps\n      results[[length(results) + 1]] <- sort(y[[t]])\n      t\n    }\n  }\n\n} \n  \n#     # Printout:\n#   cat('   t    Gini stdev', sprintf(' %3d%%', percentiles), '\\n')\n#   cat('------- ---- -----', paste(rep(' ----', length(percentiles)), collapse = ''), '\\n')\n#   fmt <- '%7d %.2f %5.1f'\n#   t <- 1\n#   for (result in results) {\n#     \n#     pop <- result$pop\n#     if (t %% (k * N / 10) == 0) {\n#       data <- sapply(percentiles, function(pct) percent(pct, pop))\n#       cat(sprintf(fmt, t, gini(pop), sd(pop), data), '\\n')\n#     }\n#   }\n#    \n#   \n# }\n\n# show(population)\n# \n# \n# \n#     library(ggplot2)\n# \n# show <- function(population, k = 40, percentiles = c(1, 10, 50, 90, 99), ...) {\n#   N <- length(population)\n#   start <- as.list(population)\n#   \n#   \n#   results <- lapply(seq(0, k * N - 1, by = N / 10), function(t) {\n#     pop <- simulate(population, T = k * N, ...)\n#     return(list(t = t, pop = sort(pop)))\n#   })\n#   \n# \n#   \n#   # Plotting\n#   times <- sapply(results, function(res) res$t)\n#   line_data <- lapply(percentiles, function(pct) sapply(results, function(res) percent(pct, res$pop)))\n#   \n#   plot(NULL, xlim = range(c(start, population)), ylim = range(times), xlab = 'wealth', ylab = 'time', main = paste(percentiles, collapse = '/'), type = 'n')\n#   grid()\n#   for (i in seq_along(percentiles)) {\n#     lines(line_data[[i]], times, col = i)\n#   }\n#   legend(\"topright\", legend = percentiles, col = seq_along(percentiles), lty = 1)\n#   \n#   # Histograms\n#   R <- range(c(population, start))\n#   par(mfrow = c(1, 2))\n#   hist(start, main = 'start', xlim = R)\n#   hist(population, main = 'end', xlim = R)\n#   \n#   # Ordered Curves\n#   order <- seq_along(population)\n#   plot(sort(start), order, type = 'l', col = 'blue', xlab = 'wealth', ylab = 'order', main = 'Ordered Curves')\n#   lines(sort(population), order, col = 'red')\n#   grid()\n#   legend(\"topright\", legend = c('start', 'end'), col = c('blue', 'red'), lty = 1)\n# }\n# \n# percent <- function(pct, items) {\n#   \"The item that is pct percent through the sorted list of items.\"\n#   return(items[min(length(items), length(items) * pct %/% 100 + 1)])\n# }\n# \n# \n# show(population)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}