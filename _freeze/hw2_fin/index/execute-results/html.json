{
  "hash": "6e95267de6e59fec09f7841ced5ef518",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Assignment 2: Simulation\"\n---\n\n\n\n\n**Make list with normal distribution data**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN  <- 5000 # Default size of the population\nMU <- 100 # Default mean of the population\n\npopulation <- rnorm(N, mean = MU, sd = MU / 5)\nhist(population) #check whether it's normally distributed\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n\n**Compute Gini coefficient**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngini <- function(y) {\n  #Compute the Gini coefficient (a measure of equality/inequality) in a population, y\n  y <- sort(y)\n  n <- length(y)\n  numer <- 2 * sum((1:n) * y[1:n]) #for i in range starts with 0 in python, indexing also with 0\n  denom <- n * sum(y)\n   return((numer / denom) - (n + 1) / n) #brackets are needed for return fun in R\n}\ngini(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1135069\n```\n\n\n:::\n:::\n\n\n\n\n**Define Transactions function**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_split <- function(A, B) {\n  #Take all the money in the pot and divide it randomly between the two actors\n  pot <- A + B\n  share <- runif(1,0,pot)\n  return(c(share, pot-share))\n}\nrandom_split(100,100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  31.6513 168.3487\n```\n\n\n:::\n:::\n\n\n\n\n**Define Interaction function**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanyone <- function(N) {\n return(sample(N,2))\n}\n\nanyone(N)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3281 1468\n```\n\n\n:::\n:::\n\n\n\n\n**Simulation**\n\nFirst, I need to figure out, whether my code idea will work.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nj <- anyone(length(population))\nj\npopulation[941]\npopulation[j[1]]\npopulation[2724]\npopulation[j[2]]\nnewmoney <- random_split(population[j[1]], population[j[2]]) \nnewmoney\npopulation[j[1]] <- newmoney[1]\npopulation[j[2]] <- newmoney[2]\n\npopulation[j[1]]\npopulation[j[2]]\n```\n:::\n\n\n\n\nNow I can define the function that will split the money between two agents and save the new money that they have for each agent (one step of the simulation)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep <- function(population, transaction_fun=random_split, interaction_fun=anyone) {\n  #Modify the population by doing one transaction.\n  j <- interaction_fun(length(population))\n  newmoney <- transaction_fun(population[j[1]], population[j[2]]) \n  population[j[1]] <- newmoney[1]\n  population[j[2]] <- newmoney[2]\n return(population)\n}\n```\n:::\n\n\n\n\nNow I can define the function of the whole simulation\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate <- function(population, T, step_fun=step, transaction_fun=random_split, interaction_fun=anyone) {\n  # Run simulation on population for T transactions; save every step in a list\n  pop_copy <- population # Make a copy of the original population list to avoid altering it\n\n  # Initialize an empty list to store steps\n  list_steps <- list()\n  \n  # Save the initial population (at t = 0)\n  list_steps[[1]] <- list(population = pop_copy, t = 0)\n  \n  # Simulate T steps\n  for (t in 1:T) {\n    # Update population using the step function\n    pop_copy <- step_fun(pop_copy, transaction_fun, interaction_fun)\n    \n    # Save the current population and the step number\n    list_steps[[t + 1]] <- list(population = pop_copy, t = t)\n  }\n  \n  return(list_steps)  # Return the list of steps\n}\n\ntest <- simulate(population = c(100,100,100,100), T=10)\n```\n:::\n\n\n\n\n**Simulation Visualization**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow <- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {\n    #Run a simulation for k*N steps, printing statistics and displaying a plot and histogram\n  N <- length(population)\n\n  # Run simulation\ny <- simulate(population, T=N*k)#every person does k transactions\n  cat('   t    Gini stdev', sprintf(' %3d%%', percentiles), '\\n')\n   cat('------- ---- -----', paste(rep(' ---- ', length(percentiles)), collapse = ''), '\\n')\n   fmt <- '%7d %.2f %5.1f'\n   \n   #make sure that the first row is added (in my simulation result, the first row has the 0 step)\n   pop <- sort(y[[1]]$population)\n      data <- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[1]]$t, gini(y[[1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n   \n\n  for (l in 1:N*k) {\n    if ((l %% (N*k %/% 10)) == 0) {#only save ten steps (which is divisable in ten steps)\n      \n      pop <- sort(y[[l+1]]$population)\n      data <- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[l+1]]$t, gini(y[[l+1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n    }\n  }\n    \n       \n       ## Making histogram ###\n       \n hist(y[[N*k]][[\"population\"]],col = rgb(1, 0, 0, 0.3), main = \"Overlapping Histograms\", xlab = \"Wealth\", ylab = \"Count\") \n \n # Overlay the second histogram\nhist(y[[1]][[\"population\"]], col = rgb(0, 0, 1, 0.3), add = TRUE)\n \nlegend(\"topright\", legend = c(\"End\", \"Start\"), \n       fill = c(rgb(1, 0, 0, 0.3), rgb(0, 0, 1, 0.3))) \n  \n} \n```\n:::\n\n\n\n\n**Part 2 of the Assignment**\n\nStarting with normal distribution:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   t    Gini stdev    1%   10%   50%   90%   99% \n------- ---- -----  ----  ----  ----  ----  ----  \n      0 0.11  20.1    53    74   100   126   145 \n  20000 0.49  96.2     1    11    71   228   440 \n  40000 0.50 101.1     1    11    68   228   463 \n  60000 0.51 102.2     1    10    67   231   484 \n  80000 0.50  99.1     1    11    68   229   452 \n 100000 0.50  98.8     1    11    70   231   448 \n 120000 0.50 101.0     1    11    68   230   475 \n 140000 0.50  99.4     1    11    68   224   460 \n 160000 0.50 101.4     1    10    68   232   462 \n 180000 0.50 100.2     1    10    67   231   450 \n 200000 0.50 100.6     1    11    68   229   453 \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\nWhat if everybody starts with the same amount of money:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN  <- 5000 # Default size of the population\ninitial_money <- 100 # Beggining wealth\n\npopulation2 <- rep(initial_money, N)\nhist(population2) #check whether it's equally distributed\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n```{.r .cell-code}\nshow(population2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   t    Gini stdev    1%   10%   50%   90%   99% \n------- ---- -----  ----  ----  ----  ----  ----  \n      0 0.00   0.0   100   100   100   100   100 \n  20000 0.48  94.2     1    12    72   229   416 \n  40000 0.50  99.0     1    10    71   227   449 \n  60000 0.51 101.8     1    10    68   230   470 \n  80000 0.50 102.5     1    11    67   232   456 \n 100000 0.51 101.3     1    10    67   233   463 \n 120000 0.50  99.4     1    11    68   232   455 \n 140000 0.51 102.4     1    10    68   230   472 \n 160000 0.50 100.8     1    10    68   233   452 \n 180000 0.50 100.0     1    11    71   230   466 \n 200000 0.50 100.1     1    11    68   229   459 \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-2.png){width=672}\n:::\n:::\n\n\n\n\nThere is still the same final pattern and the same final Gini coeffcient. The starting distribution seems to be irrelevant. From looking at the table, it seems like the switch to the final distribution happens quite quickly (already after 2000 transactions). Let me look at it more closely.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow2 <- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {\n    #Run a simulation for k*N steps, printing statistics and displaying a plot and histogram\n  N <- length(population)\n\n  # Run simulation\ny <- simulate(population, T=N*k)#every person does k transactions\n  cat('   t    Gini stdev', sprintf(' %3d%%', percentiles), '\\n')\n   cat('------- ---- -----', paste(rep(' ---- ', length(percentiles)), collapse = ''), '\\n')\n   fmt <- '%7d %.2f %5.1f'\n   \n   #make sure that the first row is added (in my simulation result, the first row has the 0 step)\n   pop <- sort(y[[1]]$population)\n      data <- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[1]]$t, gini(y[[1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n   \n\n  for (l in 1:N*k) {\n    if ((l %% (N*k %/% 20)) == 0) {#only save 20 steps (which is divisable in ten steps)\n      \n      pop <- sort(y[[l+1]]$population)\n      data <- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[l+1]]$t, gini(y[[l+1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n    }\n  }\n    \n       \n       ## Making histogram ###\n       \n hist(y[[N*k]][[\"population\"]],col = rgb(1, 0, 0, 0.3), main = \"Overlapping Histograms\", xlab = \"Wealth\", ylab = \"Count\") \n \n # Overlay the second histogram\nhist(y[[1]][[\"population\"]], col = rgb(0, 0, 1, 0.3), add = TRUE)\n\nhist(y[[(N*k)/2]][[\"population\"]], col = rgb(0, 1, 0, 0.3), add = TRUE)\n \nlegend(\"topright\", legend = c(\"End\", \"Start\", \"Middle\"), \n       fill = c(rgb(1, 0, 0, 0.3), rgb(0, 0, 1, 0.3),rgb(0, 1, 0, 0.3))) \n  \n} \n\nshow2(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   t    Gini stdev    1%   10%   50%   90%   99% \n------- ---- -----  ----  ----  ----  ----  ----  \n      0 0.11  20.1    53    74   100   126   145 \n  10000 0.45  85.7     1    13    80   211   394 \n  20000 0.49  97.4     1    10    70   230   438 \n  30000 0.49  97.5     1    10    69   227   456 \n  40000 0.49  98.4     1    12    71   229   456 \n  50000 0.49  99.1     1    11    71   222   464 \n  60000 0.50  98.7     1    11    71   231   453 \n  70000 0.50 100.1     1    11    69   221   464 \n  80000 0.50  99.9     1    10    69   230   461 \n  90000 0.50  99.1     1    10    70   231   447 \n 100000 0.50 100.9     1    10    69   233   452 \n 110000 0.50  99.5     1    10    69   230   452 \n 120000 0.50  98.9     1    10    69   229   447 \n 130000 0.50  99.0     1    11    69   234   441 \n 140000 0.50 100.7     1    10    69   229   483 \n 150000 0.50  99.2     1    10    68   231   445 \n 160000 0.51 100.6     1    10    67   233   454 \n 170000 0.50  99.2     1    11    68   232   454 \n 180000 0.50 100.3     1    11    69   229   453 \n 190000 0.51 100.3     1    10    68   234   441 \n 200000 0.50  99.9     1    11    68   232   443 \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\nIt seems that it finds a state where it's in a stable distribution and then more or less stays like this (Gini changes from 0.49-0.51). Looking at the table, it seems to happen rather quickly. If every meeting and distribution happens randomly, could it be that the distribution randomly lands on this distribution but then stays like that? Why does it stay like that? I'd like to use a smaller population to see what happens in this case.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow(population = c(100,100,100,100,100,100,100,100,100,100))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   t    Gini stdev    1%   10%   50%   90%   99% \n------- ---- -----  ----  ----  ----  ----  ----  \n      0 0.00   0.0   100   100   100   100   100 \n     40 0.38  71.7     7    23    98   171   210 \n     80 0.53 105.4     2    19    63   247   309 \n    120 0.36  68.9    19    22    81   163   226 \n    160 0.48  94.1     6    16    78   195   297 \n    200 0.56 173.7    20    30    47   130   546 \n    240 0.49  94.3     4    13    55   203   269 \n    280 0.39  72.5     8    17   107   190   190 \n    320 0.42  93.3    27    34    77   150   322 \n    360 0.42  79.5     6    13    88   178   244 \n    400 0.34  63.4    11    15   101   177   191 \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}