{
  "hash": "166e03ca269e21a6927335ff8da63636",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Assignment 2: Simulation\"\n---\n\n\n\n\n**Make list with normal distribution data**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN  <- 5000 # Default size of the population\nMU <- 100 # Default mean of the population\n\npopulation <- rnorm(N, mean = MU, sd = MU / 5)\nhist(population) #check whether it's normally distributed\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n\n**Compute Gini coefficient**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngini <- function(y) {\n  #Compute the Gini coefficient (a measure of equality/inequality) in a population, y\n  y <- sort(y)\n  n <- length(y)\n  numer <- 2 * sum((1:n) * y[1:n]) #for i in range starts with 0 in python, indexing also with 0\n  denom <- n * sum(y)\n   return((numer / denom) - (n + 1) / n) #brackets are needed for return fun in R\n}\ngini(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1135069\n```\n\n\n:::\n:::\n\n\n\n\n**Define Transactions function**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrandom_split <- function(A, B) {\n  #Take all the money in the pot and divide it randomly between the two actors\n  pot <- A + B\n  share <- runif(1,0,pot)\n  return(c(share, pot-share))\n}\nrandom_split(100,100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  31.6513 168.3487\n```\n\n\n:::\n:::\n\n\n\n\n**Define Interaction function**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanyone <- function(N) {\n return(sample(N,2))\n}\n\nanyone(N)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3281 1468\n```\n\n\n:::\n:::\n\n\n\n\n**Simulation**\n\nFirst, I need to figure out, whether my code idea will work.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nj <- anyone(length(population))\nj\npopulation[941]\npopulation[j[1]]\npopulation[2724]\npopulation[j[2]]\nnewmoney <- random_split(population[j[1]], population[j[2]]) \nnewmoney\npopulation[j[1]] <- newmoney[1]\npopulation[j[2]] <- newmoney[2]\n\npopulation[j[1]]\npopulation[j[2]]\n```\n:::\n\n\n\n\nNow I can define the function that will split the money between two agents and save the new money that they have for each agent (one step of the simulation)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep <- function(population, transaction_fun=random_split, interaction_fun=anyone) {\n  #Modify the population by doing one transaction.\n  j <- interaction_fun(length(population))\n  newmoney <- transaction_fun(population[j[1]], population[j[2]]) \n  population[j[1]] <- newmoney[1]\n  population[j[2]] <- newmoney[2]\n return(population)\n}\n```\n:::\n\n\n\n\nNow I can define the function of the whole simulation\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate <- function(population, T, step_fun=step, transaction_fun=random_split, interaction_fun=anyone) {\n  # Run simulation on population for T transactions; save every step in a list\n  pop_copy <- population # Make a copy of the original population list to avoid altering it\n\n  # Initialize an empty list to store steps\n  list_steps <- list()\n  \n  # Save the initial population (at t = 0)\n  list_steps[[1]] <- list(population = pop_copy, t = 0)\n  \n  # Simulate T steps\n  for (t in 1:T) {\n    # Update population using the step function\n    pop_copy <- step_fun(pop_copy, transaction_fun, interaction_fun)\n    \n    # Save the current population and the step number\n    list_steps[[t + 1]] <- list(population = pop_copy, t = t)\n  }\n  \n  return(list_steps)  # Return the list of steps\n}\n\ntest <- simulate(population = c(100,100,100,100), T=10)\n```\n:::\n\n\n\n\n**Simulation Visualization**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow <- function(population, k=40, percentiles=c(1, 10, 50, 90, 99)) {\n    #Run a simulation for k*N steps, printing statistics and displaying a plot and histogram\n  N <- length(population)\n\n  # Run simulation\ny <- simulate(population, T=N*k)#every person does k transactions\n  cat('   t    Gini stdev', sprintf(' %3d%%', percentiles), '\\n')\n   cat('------- ---- -----', paste(rep(' ---- ', length(percentiles)), collapse = ''), '\\n')\n   fmt <- '%7d %.2f %5.1f'\n   \n   #make sure that the first row is added (in my simulation result, the first row has the 0 step)\n   pop <- sort(y[[1]]$population)\n      data <- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[1]]$t, gini(y[[1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n   \n\n  for (l in 1:N*k) {\n    if ((l %% (N*k %/% 10)) == 0) {#only save ten steps (which is divisable in ten steps)\n      \n      pop <- sort(y[[l+1]]$population)\n      data <- sapply(percentiles, function(pct) quantile(pop, pct/100))\n       cat(sprintf(fmt, y[[l+1]]$t, gini(y[[l+1]]$population), sd(pop)), \n          sprintf(' %4.0f', data), '\\n')\n    }\n  }\n    \n       \n       ## Making histogram ###\n       \n hist(y[[N*k]][[\"population\"]],col = rgb(1, 0, 0, 0.3), main = \"Overlapping Histograms\", xlab = \"Wealth\", ylab = \"Count\") \n \n # Overlay the second histogram\nhist(y[[1]][[\"population\"]], col = rgb(0, 0, 1, 0.3), add = TRUE)\n \nlegend(\"topright\", legend = c(\"End\", \"Start\"), \n       fill = c(rgb(1, 0, 0, 0.3), rgb(0, 0, 1, 0.3))) \n  \n} \n\nshow(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   t    Gini stdev    1%   10%   50%   90%   99% \n------- ---- -----  ----  ----  ----  ----  ----  \n      0 0.11  20.1    53    74   100   126   145 \n  20000 0.49  96.2     1    11    71   228   440 \n  40000 0.50 101.1     1    11    68   228   463 \n  60000 0.51 102.2     1    10    67   231   484 \n  80000 0.50  99.1     1    11    68   229   452 \n 100000 0.50  98.8     1    11    70   231   448 \n 120000 0.50 101.0     1    11    68   230   475 \n 140000 0.50  99.4     1    11    68   224   460 \n 160000 0.50 101.4     1    10    68   232   462 \n 180000 0.50 100.2     1    10    67   231   450 \n 200000 0.50 100.6     1    11    68   229   453 \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}